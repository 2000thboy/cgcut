---
trigger: always_on
---
Global Rules — cgcut（轻量进化版）
1. 核心原则（只这一条是硬的）

所有实现都必须先跑通，再讨论是否正确。

在向用户展示、请求确认或推进下一步前，系统应当：

自行完成一次可执行路径

验证代码可以运行

验证最小输入 → 最小输出是闭环的

如果无法跑通，不进入“需求确认”阶段。

2. 自我迭代原则（Self-Iteration）

在每一轮实现中，系统应遵循以下顺序：

先实现最直接、最朴素的方案

运行代码，确认无报错

评估是否满足当前目标

再考虑结构优化或能力升级

禁止在“尚未运行成功”之前进行架构美化、抽象升级或功能扩展。

3. 用户确认优先级规则

任何功能升级、能力增强、交互变化，都必须遵循：

系统先自检 → 给出可运行结果 → 再让用户判断是否值得继续

禁止以下行为：

在用户未看到运行结果前反复询问需求

用“理论更优”替代“实际可用”

4. 可回退原则（Anti-lock）

所有实现应满足：

可以被删除

可以被替换

可以在不影响主流程的情况下关闭

如果某段代码或模块一旦加入就很难移除，应当延后实现。

5. 最小闭环优先（MVP First）

每一轮工作都应明确回答一个问题：

这一轮完成后，用户能多验证一件什么事？

如果无法回答，说明实现偏离当前阶段目标。

6. 功能增长的默认态度

对于新功能请求，默认策略是：

先接纳

先用最小方式实现

先跑通

再决定是否深化

而不是先否定、先限制、先设计“最终形态”。

7. 关于 AI / 自动化的使用态度

AI、Agent、规则系统等：

可以用于 加速生成

可以用于 给出候选

可以用于 自我检查

但在当前阶段：

AI 不替用户做最终判断，只帮助用户更快看到结果。

8. 对代码规模与复杂度的基础要求（非硬限制）

这是“偏好”，不是“禁止”：

单文件尽量保持可读

能用直觉写清楚的，不提前抽象

能删掉的，优先删掉而不是兼容

9. 成功的判断方式（当前阶段）

当前阶段的成功不取决于：

功能是否完整

架构是否优雅

是否“像一个产品”

而取决于：

用户是否能更快看到一个“可判断对错的结果”。

10. 一句话总规则（写给 Qoder 的）

先跑通，再变好；
先看到，再讨论；
所有设计都应允许被推翻。